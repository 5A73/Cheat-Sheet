# マルウェア解析における手法とツール

## ファイル形式の特定（実行環境OS／アーキテクチャ）
ファイルのヘッダに書き込まれている**マジックナンバー／シグネチャ（ファイルシグネチャ）**を解析することで、ファイルの実行環境OSやアーキテクチャを特定します。  
ファイルシグネチャ（マジックナンバー）を解析して実行環境OSやアーキテクチャを特定する具体的な手順は以下の通りです。  

ファイルシグネチャを利用した解析手順
1. 対象ファイルの準備
解析したいファイルを手元に用意します。  
ファイルが圧縮されている場合は解凍して、元のバイナリファイルを取得します。  
2. バイナリデータを確認
ファイルシグネチャは通常、ファイルの先頭数バイトに記載されています。  
バイナリデータを表示するために、以下のようなツールを使用します：
- Linux/Unix
```bash
hexdump -C <filename>
```
- Windows  
Windows Subsystem for Linux (WSL)でhexdumpを使用。  
またはHxDなどのバイナリエディタを使用。  
例:
以下はhexdumpの出力例です:
```bash
hexdump -C sample.exe
00000000  4d 5a 90 00 03 00 00 00  04 00 00 00 ff ff 00 00  |MZ............|
00000010  b8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
```
この例では、MZ（4D 5A）がWindows実行ファイル（PE形式）を示しています。    

3. シグネチャの特定
取得したバイナリデータの先頭数バイトを参照し、それが何を示すかを調査します。  
以下の表を活用して特定します。  
シグネチャ (16進数)	意味	例  
- 4D 5A	Windows PE実行ファイル (MZヘッダー)	.exe, .dll  
- 7F 45 4C 46	ELFファイル (Linux/Unix実行形式)	Linuxバイナリ  
- 89 50 4E 47	PNG画像ファイル	.png  
- 25 50 44 46	PDFファイル	.pdf  
- 50 4B 03 04	ZIPアーカイブ	.zip  
 
4. OSやアーキテクチャの特定
特定されたシグネチャに基づき、以下を確認します：
ファイル形式: どのOSやプラットフォームで利用可能か。  
アーキテクチャ: ELFの場合は、アーキテクチャ情報も含まれます。  
ELF形式の例
readelfコマンドで詳細を確認：

```bash
readelf -h <filename>
```
出力例:

ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  OS/ABI:                            UNIX - System V
  Machine:                           x86-64
この例では、x86-64アーキテクチャで、Linux環境で動作することがわかります。  

5. 自動解析ツールの使用
ファイルシグネチャを特定する自動化ツールも利用可能です：
fileコマンド:
```bash

file <filename>
```
例:
```bash
file sample.exe
sample.exe: PE32 executable (GUI) Intel 80386, for MS Windows
```
binwalk: ファイルの埋め込まれたデータやシグネチャも解析可能。  
```bash
binwalk <filename>
```
6. 追加解析
より詳細な解析が必要な場合、以下を試してください：
GhidraやIDA Proでファイルを逆アセンブル。  
stringsコマンドで埋め込まれたテキストを確認：
```bash
strings <filename>
```
---

## ハッシュ値の取得
ファイル全体をハッシュ関数を用いてハッシュ値を取得します。  得られたハッシュ値は以下のような目的で活用されます：
- ソフトウェアやツールへの情報展開が容易になる。  
- オンライン上でインジケータを用いて有益な情報を検索するキーワードとなる。  

---

## 類似性を用いた解析
現実的には、マルウェアのインジケータ部分が日々変化するため、**ハッシュ値をインジケータとして有効活用できるライフタイムは短い**です。  そのため、類似性を定量的に算出する解析手法が重要となります。  

### 主な手法
- **ファジーハッシュ（Fuzzy Hashing）**  
  コンテンツ内のデータを対象に類似度を算出します。  類似度が高いほど算出されたハッシュ値の文字や文字の並びが近くなります。  ファジーハッシュは概念であり、具体的な手法はツールにより異なります。  

- **インポートハッシュ（Import Hash）**  
  PEファイルのインポート関数とその順序性からハッシュ値を算出します。  同一のマルウェアで接続先などのみが変化している場合、類似性算出に有効です。  ただし、機能追加が行われた場合にはハッシュ値が異なる特性があります。  

- **セクションハッシュ（Section Hash）**  
  PEヘッダ内の各セクションを対象にハッシュ値を算出する手法です。  

- **impfuzzy**  
  インポート関数のテーブルを対象にファジーハッシュを用いて類似度を算出する手法です。  機能追加や一部変更にも対応可能で、マルウェアファミリーや亜種の判別に役立ちます。  

---

## 文字列の抽出
プログラムの動作に関する文字列やインジケータとなる情報を取得します。  ASCIIだけでなく**Unicode**を利用している場合が多いため、両方を対象にデータを取得する必要があります。  

- **FLOSS (FireEye Labs Obfuscated String Solver)**  
  難読化された文字列を容易にデコードし、結果を確認できるツールです。  

---

## 難読化対策
多くのマルウェアは解析を妨害する目的で難読化されています。  難読化されたファイルをデコードするためには、難読化の種類を特定し適切な手段を選択する必要があります。  

### 主な難読化手法
1. **パッカー**  
   プログラムを圧縮することでコンテンツを難読化します。  パッキングされたプログラムには解凍モジュールが同梱されており、メモリ上でコンテンツを展開して元の実行形式に復元します。  
   - 例: UPX形式

2. **クリプター**  
   コンテンツを暗号化して難読化を行います。  暗号化されたプログラムには復号モジュールが同梱されており、メモリ上で復号されたコンテンツを展開して元の実行形式に復元します。  

- **Exeinfo PE**  
  難読化方式を容易に検出できるツールです。  
![image](https://github.com/user-attachments/assets/47860c9f-bd71-460a-a86f-9e4bcd23d9bb)

---

## PE解析
**PE（Portable Executable）ファイル形式**は、Windowsの実行ファイル形式です。  コンパイル時にヘッダ領域に参照ライブラリや関数、リソースなどの情報が記載されるため、以下のような解析が可能です：
- プログラムの挙動に関する重要な情報をヘッダから取得。  
- 呼び出すAPIの数が極端に少ない場合は難読化の可能性を示唆。  

また、**リソース領域**にはプログラムに内蔵された別のファイルが含まれている場合があります。  
- **Resource Hacker**  
  内蔵ファイルを抽出するためのツールです。  
